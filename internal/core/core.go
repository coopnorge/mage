package core

import (
	"embed"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strings"

	doublestar "github.com/bmatcuk/doublestar/v4"
)

const (
	// OutputDir is the destination for CI artifacts
	OutputDir = "./var"
)

// GetRelativeRootPath ...
func GetRelativeRootPath(absRootPath, workDirRel string) (string, error) {
	workDirAbs := path.Join(absRootPath, workDirRel)
	relativeRootPath, err := filepath.Rel(workDirAbs, absRootPath)
	if err != nil {
		return "", err
	}
	return relativeRootPath, nil
}

// WriteTempFile writes the content to a temp file in the provided with a
// random prefix and the provided suffix. Returns a cleanup function that the
// caller is expected to call. If cleanup errors it will panic.
func WriteTempFile(directory, suffix, content string) (string, func(), error) {
	err := os.MkdirAll(directory, 0700)
	if err != nil {
		return "", func() {}, err
	}
	file, err := os.CreateTemp(directory, fmt.Sprintf("*-%s", suffix))
	if err != nil {
		return "", func() {}, err
	}

	cleanup := func() {
		err := os.Remove(file.Name())
		if err != nil {
			panic(err)
		}
	}

	_, err = file.WriteString(content)
	if err != nil {
		defer cleanup()
		return "", func() {}, err
	}
	return file.Name(), cleanup, nil
}

// WriteTempFiles writes the content to a temp directory with a
// random prefix and the provided suffix. Returns a cleanup function that the
// caller is expected to call. If cleanup errors it will panic.
func WriteTempFiles(directory string, suffix string, fsys embed.FS) (string, func(), error) {
	// Create directory dir if needed
	if err := os.MkdirAll(directory, 0o700); err != nil {
		return "", func() {}, err
	}

	// Create a temp directory inside parent
	dir, err := os.MkdirTemp(directory, fmt.Sprintf("*-%s", suffix))
	if err != nil {
		return "", func() {}, err
	}

	cleanup := func() {
		err = os.RemoveAll(dir)
		if err != nil {
			panic(err)
		}
	}

	// Walk embedded FS and recreate structure
	err = fs.WalkDir(fsys, ".", func(path string, d fs.DirEntry, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}
		if path == "." {
			return nil
		}

		dest := filepath.Join(dir, path)

		if d.IsDir() {
			return os.MkdirAll(dest, 0o755)
		}

		data, err := fsys.ReadFile(path)
		if err != nil {
			return err
		}

		if err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil {
			return err
		}

		return os.WriteFile(dest, data, 0o644)
	})

	if err != nil {
		defer cleanup()
		return "", func() {}, err
	}

	return dir, cleanup, nil
}

// MkdirTemp creates a new temporary directory in the default directory for
// temporary files, as returned by TempDir, and returns the pathname of the new
// directory. The new directory's name is generated by adding a random string
// to the end of the name of the directory of the repository. The directory is
// created with mode 0o700 (before umask). Multiple programs or goroutines
// calling MkdirTemp simultaneously will not choose the same directory. It is
// the caller's responsibility to call the returned cleanup function when the
// directory is no longer needed. If cleanup errors it will panic.
func MkdirTemp() (string, func(), error) {
	workDir, err := os.Getwd()
	if err != nil {
		return "", func() {}, err
	}
	path, err := os.MkdirTemp("", path.Base(workDir))
	if err != nil {
		return "", func() {}, err
	}
	cleanup := func() {
		err := os.RemoveAll(path)
		// Dont panic in CI. GHA  has some issues with deleting
		if err != nil && os.Getenv("CI") != "true" {
			panic(err)
		}
	}
	return path, cleanup, nil
}

// IsDotDirectory checks if the supplied direcory is starts with a dot.
func IsDotDirectory(path string, d fs.DirEntry) bool {
	if !d.IsDir() {
		return false
	}
	if filepath.Base(path) == "." {
		return false
	}
	return strings.HasPrefix(filepath.Base(path), ".")
}

// CompareChangesToPaths takes a list of paths comapring if the first matches
// the latter. You can also add additional globs to match the first list.
func CompareChangesToPaths(changes []string, paths []string, additionalGlobs []string) (bool, error) {
	for _, change := range changes {
		for _, p := range paths {
			match, err := path.Match(fmt.Sprintf("%s/*", p), change)
			if err != nil {
				return false, err
			}
			if match {
				return true, nil
			}
		}
		for _, pattern := range additionalGlobs {
			if pattern == "" {
				continue
			}
			matchAdditional, err := doublestar.Match(pattern, change)
			if err != nil {
				return false, err
			}
			if matchAdditional {
				return true, nil
			}
		}
	}
	return false, nil
}
