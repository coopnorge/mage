package core

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strings"

	doublestar "github.com/bmatcuk/doublestar/v4"
	"github.com/magefile/mage/sh"
)

const (
	// OutputDir is the destination for CI artifacts
	OutputDir = "./var"
)

// GetRelativeRootPath ...
func GetRelativeRootPath(absRootPath, workDirRel string) (string, error) {
	workDirAbs := path.Join(absRootPath, workDirRel)
	relativeRootPath, err := filepath.Rel(workDirAbs, absRootPath)
	if err != nil {
		return "", err
	}
	return relativeRootPath, nil
}

// WriteTempFile writes the content to a temp file in the provided with a
// random prefix and the provided suffix. Returns a cleanup function that the
// caller is expected to call. If cleanup errors it will panic.
func WriteTempFile(directory, suffix, content string) (string, func(), error) {
	err := os.MkdirAll(directory, 0o700)
	if err != nil {
		return "", func() {}, err
	}
	file, err := os.CreateTemp(directory, fmt.Sprintf("*-%s", suffix))
	if err != nil {
		return "", func() {}, err
	}

	cleanup := func() {
		// check if file exist if not skip deletion
		_, err := os.Stat(file.Name())
		if errors.Is(err, os.ErrNotExist) {
			return
		}
		if err != nil {
			panic(err)
		}
		err = os.Remove(file.Name())
		if err != nil {
			panic(err)
		}
	}

	_, err = file.WriteString(content)
	if err != nil {
		defer cleanup()
		return "", func() {}, err
	}
	return file.Name(), cleanup, nil
}

// MkdirTemp creates a new temporary directory in the default directory for
// temporary files, as returned by TempDir, and returns the pathname of the new
// directory. The new directory's name is generated by adding a random string
// to the end of the name of the directory of the repository. The directory is
// created with mode 0o700 (before umask). Multiple programs or goroutines
// calling MkdirTemp simultaneously will not choose the same directory. It is
// the caller's responsibility to call the returned cleanup function when the
// directory is no longer needed. If cleanup errors it will panic.
func MkdirTemp() (string, func(), error) {
	tmpRoot := ""
	rootDir, found := os.LookupEnv("MAGE_TEMP_ROOT")
	if found {
		tmpRoot = rootDir
	}
	workDir, err := os.Getwd()
	if err != nil {
		return "", func() {}, err
	}
	path, err := os.MkdirTemp(tmpRoot, path.Base(workDir))
	if err != nil {
		return "", func() {}, err
	}
	safePath, err := filepath.EvalSymlinks(path)
	if err != nil {
		return "", func() {}, err
	}
	cleanup := func() {
		err := os.RemoveAll(safePath)
		// Dont panic in CI. GHA  has some issues with deleting
		if err != nil && os.Getenv("CI") != "true" {
			panic(err)
		}
	}
	return safePath, cleanup, nil
}

// IsDotDirectory checks if the supplied direcory is starts with a dot.
func IsDotDirectory(path string, d fs.DirEntry) bool {
	if !d.IsDir() {
		return false
	}
	if filepath.Base(path) == "." {
		return false
	}
	return strings.HasPrefix(filepath.Base(path), ".")
}

// CompareChangesToPaths takes a list of paths comapring if the first matches
// the latter. You can also add additional globs to match the first list.
func CompareChangesToPaths(changes []string, paths []string, additionalGlobs []string) (bool, error) {
	for _, change := range changes {
		for _, p := range paths {
			if change == p {
				return true, nil
			}

			match, err := path.Match(fmt.Sprintf("%s/*", p), change)
			if err != nil {
				return false, err
			}
			if match {
				return true, nil
			}
		}
		for _, pattern := range additionalGlobs {
			if pattern == "" {
				continue
			}
			matchAdditional, err := doublestar.Match(pattern, change)
			if err != nil {
				return false, err
			}
			if matchAdditional {
				return true, nil
			}
		}
	}
	return false, nil
}

// Verbose returns true if the magefile is running in verbose mode.
func Verbose() bool {
	// Check for the MAGEFILE_VERBOSE environment variable
	v := os.Getenv("MAGEFILE_VERBOSE")
	return v == "1" || strings.EqualFold(v, "true")
}

// FileExists checks if a file exists at the given path.
// Returns true if the file exists, false otherwise.
func FileExists(filePath string) bool {
	_, err := os.Stat(filePath)
	return err == nil
}

// FileExistsInDirectory checks if a file with the given name exists in the specified directory.
// Returns true if the file exists, false otherwise.
func FileExistsInDirectory(directory, filename string) bool {
	fullPath := filepath.Join(directory, filename)
	return FileExists(fullPath)
}

// GetRepoRoot returns the absolute path to the repository root directory.
// It uses git to find the top-level directory of the repository.
// If git is not available or not in a git repository, it falls back to the current working directory.
func GetRepoRoot() (string, error) {
	// Try to get repo root from git
	repoRoot, err := sh.Output("git", "rev-parse", "--show-toplevel")
	if err == nil {
		return strings.TrimSpace(repoRoot), nil
	}

	// Fallback to current working directory if not in a git repo
	cwd, err := os.Getwd()
	if err != nil {
		return "", err
	}
	return cwd, nil
}

// GetAbsWorkDir accepts a directory as string and joins it with the current workdir
// directory to return a absolute directory. If the supplied directory is
// already absolute it will just return the input.
func GetAbsWorkDir(workdir string) string {
	if filepath.IsAbs(workdir) {
		return workdir
	}
	cwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	return filepath.Join(cwd, workdir)
}
