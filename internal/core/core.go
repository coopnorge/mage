package core

import (
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	doublestar "github.com/bmatcuk/doublestar/v4"
)

const (
	// OutputDir is the destination for CI artifacts
	OutputDir = "./var"
)

// GetRelativeRootPath ...
func GetRelativeRootPath(absRootPath, workDirRel string) (string, error) {
	workDirAbs := path.Join(absRootPath, workDirRel)
	relativeRootPath, err := filepath.Rel(workDirAbs, absRootPath)
	if err != nil {
		return "", err
	}
	return relativeRootPath, nil
}

// WriteTempFile writes the content to a temp file in the provided with a
// random prefix and the provided suffix. Returns a cleanup function that the
// caller is expected to call. If cleanup errors it will panic.
func WriteTempFile(directory, suffix, content string) (string, func(), error) {
	err := os.MkdirAll(directory, 0700)
	if err != nil {
		return "", func() {}, err
	}
	file, err := os.CreateTemp(directory, fmt.Sprintf("*-%s", suffix))
	if err != nil {
		return "", func() {}, err
	}

	cleanup := func() {
		err := os.Remove(file.Name())
		if err != nil {
			panic(err)
		}
	}

	_, err = file.WriteString(content)
	if err != nil {
		defer cleanup()
		return "", func() {}, err
	}
	return file.Name(), cleanup, nil
}

// MkdirTemp creates a new temporary directory in the default directory for
// temporary files, as returned by TempDir, and returns the pathname of the new
// directory. The new directory's name is generated by adding a random string
// to the end of the name of the directory of the repository. The directory is
// created with mode 0o700 (before umask). Multiple programs or goroutines
// calling MkdirTemp simultaneously will not choose the same directory. It is
// the caller's responsibility to call the returned cleanup function when the
// directory is no longer needed. If cleanup errors it will panic.
func MkdirTemp() (string, func(), error) {
	workDir, err := os.Getwd()
	if err != nil {
		return "", func() {}, err
	}
	path, err := os.MkdirTemp("", path.Base(workDir))
	if err != nil {
		return "", func() {}, err
	}
	cleanup := func() {
		err := os.RemoveAll(path)
		// Dont panic in CI. GHA  has some issues with deleting
		if err != nil && os.Getenv("CI") != "true" {
			panic(err)
		}
	}
	return path, cleanup, nil
}

// IsDotDirectory checks if the supplied direcory is starts with a dot.
func IsDotDirectory(path string, d fs.DirEntry) bool {
	if !d.IsDir() {
		return false
	}
	if filepath.Base(path) == "." {
		return false
	}
	return strings.HasPrefix(filepath.Base(path), ".")
}

// CompareChangesToPaths takes a list of paths comapring if the first matches
// the latter. You can also add additional globs to match the first list.
func CompareChangesToPaths(changes []string, paths []string, additionalGlobs []string) (bool, error) {
	for _, change := range changes {
		for _, p := range paths {
			if change == p {
				return true, nil
			}

			match, err := path.Match(fmt.Sprintf("%s/*", p), change)
			if err != nil {
				return false, err
			}
			if match {
				return true, nil
			}
		}
		for _, pattern := range additionalGlobs {
			if pattern == "" {
				continue
			}
			matchAdditional, err := doublestar.Match(pattern, change)
			if err != nil {
				return false, err
			}
			if matchAdditional {
				return true, nil
			}
		}
	}
	return false, nil
}

// FileExists checks if the file in given path exists or not.
func FileExists(path string) bool {
	_, err := os.Stat(path)

	return err == nil
}

// CreateOrAppendFile creates a file with a given content or appends content to existing file
// at the specified path
func CreateOrAppendFile(path string, content string) error {
	file, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

	defer func() {
		if err := file.Close(); err != nil {
			log.Printf("Failed to close file: %v", err)
		}
	}()

	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}

	if _, err := io.WriteString(file, content); err != nil {
		return fmt.Errorf("failed to write to file: %w", err)
	}

	return nil
}

// IsDirectoryEmpty checks if the specified directory is empty
// and returns true if it contains no files or subdirectories.
// Also return error if there is any while reading the directory
func IsDirectoryEmpty(dirPath string) (bool, error) {
	entries, err := os.ReadDir(dirPath)

	if err != nil {
		return true, err
	}

	return len(entries) == 0, nil
}
