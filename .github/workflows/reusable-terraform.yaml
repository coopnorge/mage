concurrency:
  group: reusable-terraform-${{ github.workflow }}-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true
on:
  workflow_call:
    inputs: {}
    secrets: {}

jobs:
  validate-terraform:
    name: Terraform CI
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: "Setup Spacelift Credentials"
        run: |
          set -x
          mkdir -p $HOME/.terraform.d
          CREDS_FILE=$HOME/.terraform.d/credentials.tfrc.json
          cat << EOF > $CREDS_FILE
          {
          "credentials": {
            "spacelift.io" : {
              "token": "${SPACELIFT_READ_TOKEN:=EMPTY}"
              }
            }
          }
          EOF
        env:
          SPACELIFT_READ_TOKEN: ${{ secrets.SPACELIFT_READ_TOKEN }}

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: "stable"
          cache-dependency-path: "**/go.sum"
      - name: Install go Tools
        run: go install tool

      - name: Code Validation
        id: validate
        run: go tool mage terraform:validate
        env:
          GITHUB_TOKEN: ${{ secrets.REVIEWBOT_GITHUB_TOKEN }}

      - name: Cleanup
        if: always()
        run: rm -fr $HOME/.terraform.d/credentials.tfrc.json || true

    permissions:
      contents: read
      pull-requests: read

  check-for-spacelift-proposed:
    permissions:
      contents: read
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.REVIEWBOT_GITHUB_TOKEN }}
      PALLET_FILE_PATH: .pallet/gitconfig.yaml
      REQUIRED_CHECK: spacelift/proposed
      GIT_REV: ${{ github.event.pull_request.head.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      - name: check if spacelift/proposed exists as a required check in branch protection
        shell: bash
        run: |
          set -euo pipefail

          get_spacelift_stack_names() {
            local repo_name="$1"
            local commit_id="$2"

            check_suite_ids=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/$repo_name/commits/$commit_id/check-suites \
              | yq -Pe '.check_suites[] | select(.app.slug == "spacelift-io").id')

            while IFS=$'\t' read -r id; do
              names=$(gh api \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                /repos/$repo_name/check-suites/$id/check-runs \
                --jq '.check_runs[].name')
              while IFS= read -r name; do
                stack="${name#*/}"
                # Skip Spacelift aggregated checks
                if [[ "$stack" == "proposed" ]] || [[ "$stack" == "tracked" ]] || [[ "$stack" == "modules" ]]; then
                  continue
                fi
                printf '%s\n' "$stack"
              done <<< "$names"
            done <<< "$check_suite_ids"
          }

          if [ ! -f "$PALLET_FILE_PATH" ]; then
            echo "'$PALLET_FILE_PATH' not found. Not a pallet project."
            exit 0
          fi

          if yq -e ".spec.branches.protection[].requiredStatusChecks.checks[] | select(. == \"$REQUIRED_CHECK\")" "$PALLET_FILE_PATH" >/dev/null; then
            echo "found '$REQUIRED_CHECK' as a required check"
            exit 0
          fi

          echo "Getting stack names for repo $GITHUB_REPOSITORY and rev $GIT_REV"
          stack_names=$(get_spacelift_stack_names "$GITHUB_REPOSITORY" "$GIT_REV")
          echo stack_names: $stack_names

          # If no stacks exist, skip requirement
          if [[ -z "$stack_names" ]]; then
            echo "No Spacelift stacks detected. Skipping '$REQUIRED_CHECK' requirement."
            exit 0
          fi

          echo "'$REQUIRED_CHECK' not found as a required check. Please add it in '.spec.branches.protection[].requiredStatusChecks.checks' in '$PALLET_FILE_PATH'."
          exit 1

  spacelift:
    name: Spacelift CI
    permissions:
      checks: read
      contents: read
      pull-requests: write
    runs-on: ubuntu-24.04
    needs: ['validate-terraform']
    steps:
      #- uses: actions/checkout@v6
      - name: Waiting for checks suites to populate
        run: sleep 10

      - name: cancel old proposed runs in the same branch
        id: spacelift-check
        env:
          GH_TOKEN: ${{ github.token }}
          GIT_REV: ${{ github.event.pull_request.head.sha }}
          GIT_BRANCH: ${{ github.event.pull_request.head.ref }}
          SPACELIFT_READ_TOKEN: ${{ secrets.spacelift-read-token }}
          SPACELIFT_ORG: coopnorge
        shell: bash
        run: |
          set -euo pipefail

          get_spacelift_bearer_token() {
            local api_input=$(echo "$1" | base64 -d 2>/dev/null)
            IFS=':' read -r _ api_id api_secret <<< "$api_input"

            jq -n --arg id "$api_id" --arg secret "$api_secret" \
              '{"query":"mutation($id:ID!,$secret:String!){ apiKeyUser(id:$id, secret:$secret){ jwt } }",
                  "variables":{"id":$id,"secret":$secret}}' \
              | curl -s "https://$SPACELIFT_ORG.app.spacelift.io/graphql" \
                  -H "Content-Type: application/json" \
                  -d @- \
              | jq -r '.data.apiKeyUser.jwt'
          }

          # Exit codes:
          # 0 = printed at least one run
          # 1 = underlying tool error (token/curl/jq)
          # 2 = valid JSON but no matching runs
          get_active_spacelift_runs() {
            local branch="$1"
            local stack_id="$2"
            local token out result

            token=$(get_spacelift_bearer_token "$SPACELIFT_READ_TOKEN") || return 1

            out=$(
              curl -fsS "https://$SPACELIFT_ORG.app.spacelift.io/graphql" \
              -H "Authorization: Bearer $token" \
              -H "Content-Type: application/json" \
              -d '{"query":"query($id:ID!){ stack(id:$id){ runs{ id state type createdAt branch commit{ hash } } proposedRuns{ id state type createdAt branch commit{ hash } } } }","variables":{"id":"'"$stack_id"'"}}'
              ) || return 1

            # jq errors (e.g., invalid JSON)
            result=$(jq -r --arg b "$branch" '
              (.data?.stack? // {runs: [], proposedRuns: []}) as $s
                | ($s.runs // []) + ($s.proposedRuns // [])
                | map(select(
                .branch == $b and
                (.state | IN("QUEUED","INITIALIZING","PREPARING","READY","PLANNING"))
                ))
                | sort_by(.createdAt)
                | .[]
                | "\(.createdAt)\t\(.commit.hash // "-")\t\(.id)"
                ' <<<"$out") || return 1

            [ -n "$result" ] || return 2
            printf '%s\n' "$result"
          }

          stop_spacelift_run() {
            local stack_id="$1"
            local run_id="$2"
            local token=$(get_spacelift_bearer_token "$SPACELIFT_READ_TOKEN")

            # Try to stop the run first
            local stop_json
            stop_json=$(
            jq -n --arg stack "$stack_id" --arg run "$run_id" \
              '{"query":"mutation($stack:ID!,$run:ID!){ runStop(stack:$stack, run:$run){ id state } }",
              "variables":{"stack":$stack,"run":$run}}' \
              | curl -s https://$SPACELIFT_ORG.app.spacelift.io/graphql \
                  -H "Authorization: Bearer $token" \
                  -H "Content-Type: application/json" \
                  -d @-
              )

            if [[ "$(jq -r '.data.runStop.id // empty' <<<"$stop_json")" == "$run_id" ]]; then
              echo "run $run_id stopped"
              return 0
            fi

            # If not stoppable, try to discard it
            local discard_json
            discard_json=$(
            jq -n --arg stack "$stack_id" --arg run "$run_id" \
              '{"query":"mutation($stack:ID!,$run:ID!){ runDiscard(stack:$stack, run:$run){ id state } }",
              "variables":{"stack":$stack,"run":$run}}' \
              | curl -s https://$SPACELIFT_ORG.app.spacelift.io/graphql \
                  -H "Authorization: Bearer $token" \
                  -H "Content-Type: application/json" \
                  -d @-
            )

            if [[ "$(jq -r '.data.runDiscard.id // empty' <<<"$discard_json")" == "$run_id" ]]; then
              echo "run $run_id discarded"
              return 0
            fi

            # Try to cancel
            local cancel_json
            cancel_json=$(
            jq -n --arg stack "$stack_id" --arg run "$run_id" \
              '{"query":"mutation($stack:ID!,$run:ID!){ runCancel(stack:$stack, run:$run){ id state } }",
                    "variables":{"stack":$stack,"run":$run}}' \
              | curl -s https://$SPACELIFT_ORG.app.spacelift.io/graphql \
                  -H "Authorization: Bearer $token" \
                  -H "Content-Type: application/json" \
                  -d @-
              )

            if [[ "$(jq -r '.data.runCancel.id // empty' <<<"$cancel_json")" == "$run_id" ]]; then
              echo "run $run_id canceled"
              return 0
            fi

            echo "run $run_id unchanged"
          }

          get_spacelift_stack_names() {
            local repo_name="$1"
            local commit_id="$2"

            check_suite_ids=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/$repo_name/commits/$commit_id/check-suites \
              | yq -Pe '.check_suites[] | select(.app.slug == "spacelift-io").id')

            while IFS=$'\t' read -r id; do
              names=$(gh api \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                /repos/$repo_name/check-suites/$id/check-runs \
                --jq '.check_runs[].name')
              while IFS= read -r name; do
                stack="${name#*/}"
                # Skip Spacelift aggregated checks
                if [[ "$stack" == "proposed" ]] || [[ "$stack" == "tracked" ]] || [[ "$stack" == "modules" ]]; then
                  continue
                fi
                printf '%s\n' "$stack"
              done <<< "$names"
            done <<< "$check_suite_ids"
          }

          echo "Getting stack names for repo $GITHUB_REPOSITORY and rev $GIT_REV"
          stack_names=$(get_spacelift_stack_names "$GITHUB_REPOSITORY" "$GIT_REV")
          echo stack_names: $stack_names

          while read -r stack_name; do
            echo "Getting stack runs for $stack_name on branch $GIT_BRANCH"
            if stack_runs=$(get_active_spacelift_runs "$GIT_BRANCH" "$stack_name"); then
              echo "stack_runs: $stack_runs"
            elif [ $? -eq 2 ]; then
              echo "No active runs for branch $GIT_BRANCH on stack $stack_name"
              continue
            fi

            latest_run="$(printf '%s\n' "$stack_runs" | tail -n1)"
            echo latest_run: $latest_run
            IFS=$'\t' read -r latest_ts latest_hash latest_id <<< "$latest_run"
            current_run="$(printf '%s\n' "$stack_runs" | awk -v rev="$GIT_REV" -F'\t' '$2==rev {print; exit}')"
            echo current_run: $current_run
            IFS=$'\t' read -r current_ts current_hash current_id <<< "$current_run"

            if [[ "$latest_hash" == "$current_hash" ]]; then
              # only stop others if our run is the latest
              while IFS=$'\t' read -r ts hash id; do
                if [[ $id != "" ]]; then
                  echo "Processing run: $id"
                  if [[ "$current_hash" != "$hash" ]]; then
                    echo "Stopping run: $id, stack: $stack_name"
                    stop_spacelift_run "$stack_name" "$id"
                  else
                    echo "Not stopping current run: $id, stack: $stack_name"
                  fi
                fi
              done <<< "$stack_runs"
            else
              echo "Later run exists, skipping"
            fi
          done <<< "$stack_names"
